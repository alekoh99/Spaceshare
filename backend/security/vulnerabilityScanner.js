const crypto = require('crypto');

class VulnerabilityScanner {
  constructor() {
    this.patterns = {
      // XSS patterns
      xss: [
        /<script[^>]*>.*?<\/script>/gi,
        /javascript:/gi,
        /on\w+\s*=/gi,
        /eval\(/gi,
      ],
      // SQL injection patterns
      sqlInjection: [
        /(\bunion\b|\bselect\b|\binsert\b|\bupdate\b|\bdelete\b)/gi,
        /(--|#|\/\*|\*\/)/g,
        /(\bor\b|\band\b)\s*1\s*=\s*1/gi,
      ],
      // Command injection
      commandInjection: [
        /[;&|`$()]/g,
      ],
      // Path traversal
      pathTraversal: [
        /\.\.\//g,
        /\.\.%2f/gi,
      ],
    };
  }

  scanForXSS(input) {
    if (typeof input !== 'string') return false;

    for (const pattern of this.patterns.xss) {
      if (pattern.test(input)) {
        return true;
      }
    }
    return false;
  }

  scanForSQLInjection(input) {
    if (typeof input !== 'string') return false;

    for (const pattern of this.patterns.sqlInjection) {
      if (pattern.test(input)) {
        return true;
      }
    }
    return false;
  }

  scanForCommandInjection(input) {
    if (typeof input !== 'string') return false;

    for (const pattern of this.patterns.commandInjection) {
      if (pattern.test(input)) {
        return true;
      }
    }
    return false;
  }

  scanForPathTraversal(input) {
    if (typeof input !== 'string') return false;

    for (const pattern of this.patterns.pathTraversal) {
      if (pattern.test(input)) {
        return true;
      }
    }
    return false;
  }

  scanInput(input, type = 'all') {
    const vulnerabilities = [];

    if (type === 'all' || type === 'xss') {
      if (this.scanForXSS(input)) {
        vulnerabilities.push('XSS');
      }
    }

    if (type === 'all' || type === 'sql') {
      if (this.scanForSQLInjection(input)) {
        vulnerabilities.push('SQL_INJECTION');
      }
    }

    if (type === 'all' || type === 'command') {
      if (this.scanForCommandInjection(input)) {
        vulnerabilities.push('COMMAND_INJECTION');
      }
    }

    if (type === 'all' || type === 'path') {
      if (this.scanForPathTraversal(input)) {
        vulnerabilities.push('PATH_TRAVERSAL');
      }
    }

    return {
      vulnerable: vulnerabilities.length > 0,
      vulnerabilities,
    };
  }

  sanitizeInput(input) {
    let sanitized = input;

    // Remove potential XSS
    sanitized = sanitized.replace(/<[^>]*>/g, '');
    sanitized = sanitized.replace(/javascript:/gi, '');
    sanitized = sanitized.replace(/on\w+\s*=/gi, '');

    // Remove potential SQL injection patterns
    sanitized = sanitized.replace(/['";]/g, '');
    sanitized = sanitized.replace(/(--|#|\/\*|\*\/)/g, '');

    // Remove potential command injection
    sanitized = sanitized.replace(/[;&|`$()]/g, '');

    return sanitized;
  }
}

module.exports = new VulnerabilityScanner();
